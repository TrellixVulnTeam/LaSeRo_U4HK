import os
import json

import numpy as np
import rasterio
import rasterio.features
import geopandas as gpd


def calculate_results(diff_histogram):
    """
    @param diff_histogram: np.histogram of a 2-class diff raster between a model prediction
    and the underlying ground-truth

    @returns dict: lots of metrics that describe the quality of the prediction

    **NOTE** This will eventually need to be generalized to an n-class diff raster
    """

    stats = {}
    stats["total_pixels"] = diff_histogram[0] + diff_histogram[1] + diff_histogram[2] + diff_histogram[3]
    stats["correct"] = diff_histogram[0] + diff_histogram[3]
    stats["incorrect"] = diff_histogram[1] + diff_histogram[2]
    
    stats["notrock"] = diff_histogram[0]
    stats["false_notrock"] = diff_histogram[1]
    stats["false_rock"] = diff_histogram[2]
    stats["rock"] = diff_histogram[3]
                    
    stats["accuracy"] = stats["correct"] / stats["total_pixels"]
    stats["classification_accuracy"] = stats["rock"] / (stats["rock"] + stats["false_rock"] + stats["false_notrock"])
    stats["rock_omission"] = diff_histogram[1] / (diff_histogram[1] + diff_histogram[3])
    stats["rock_commission"] = diff_histogram[2] / (diff_histogram[2] + diff_histogram[3])
    stats["notrock_omission"] = diff_histogram[2] / (diff_histogram[0] + diff_histogram[2])
    stats["notrock_commission"] = diff_histogram[1] / (diff_histogram[0] + diff_histogram[1])
    stats["f1_rock"] = 2 * ((stats["rock_omission"] * stats["rock_commission"]) / (stats["rock_omission"] + stats["rock_commission"]))

    stats["rock_producers"] = diff_histogram[3] / (diff_histogram[1] + diff_histogram[3]) * 100
    stats["notrock_producers"] = diff_histogram[0] / (diff_histogram[0] + diff_histogram[2]) * 100
    stats["rock_users"] = diff_histogram[3] / (diff_histogram[2] + diff_histogram[3]) * 100
    stats["notrock_users"] = diff_histogram[0] / (diff_histogram[0] + diff_histogram[1]) * 100

    return stats


class TestRegion:
    """
    This class is a singleton-pattern mess that needs to be refactored eventually
    """
    def __init__(self, test_region_window_path, groundtruth_source_dir='/content/drive/My Drive/qc/manual_labels'):
        self.window_path = test_region_window_path
        self.window = self.load_window(self.window_path)

        self.groundtruth_source_dir = groundtruth_source_dir
        self.groundtruth = {}
        self.groundtruth_class_count = None

    @staticmethod
    def load_window(path):
        with open(path, 'r') as f:
            return json.load(f)

    def load_groundtruth(self):
        groundtruth_class_max = 0
        for i in self.window:
            self.groundtruth[i] = np.load(os.path.join(self.groundtruth_source_dir, f'{i}_man.npy'))
            groundtruth_class_max = max(groundtruth_class_max, len(np.unique(self.groundtruth[i])))
        self.groundtruth_class_count = groundtruth_class_max

    def assemble_test_region_mosaic(self, raster_source_dir, test_region_window, source_suffix='_output'):
        row_vals = [i[0] for i in test_region_window['chunks']]
        col_vals = [i[1] for i in test_region_window['chunks']]
        row_range = (min(row_vals), max(row_vals))
        col_range = (min(col_vals), max(col_vals))
    
        mosaic_rows = []
        for i in range(row_range[0], row_range[1] + 1):
            row = []
            for j in range(col_range[0], col_range[1] + 1):
                row.append(np.load(os.path.join(raster_source_dir, "chunk_{}_{}{}.npy".format(i, j, source_suffix))))
            
            mosaic_rows.append(np.concatenate(tuple(row), axis=1))
        
        mosaic = np.concatenate(tuple(mosaic_rows), axis=0)
        
        return mosaic[test_region_window["row"]: test_region_window["row"] + test_region_window["height"],
                                test_region_window["col"]: test_region_window["col"] + test_region_window["width"]]

    def load_output_mosaics(self, output_dir):
        """
        @param output_dir: string, the path to the directory where rasters generated by a model's
        predictions are stored in directories by scene_id/chunk_row_col_output.npy
        
        @returns dict containing numpy arrays
        """
        mosaics = {}
        
        for i in self.window:
            if i == 'ryder_bay_abj':
                scene_dir = os.path.join(output_dir, "LC82201072015017LGN0")
            else:
                scene_dir = os.path.join(output_dir, i)

            if os.path.exists(scene_dir) and len(os.listdir(scene_dir)) > 0:
                mosaics[i] = self.assemble_test_region_mosaic(scene_dir, self.window[i])

        return mosaics

    def generate_diffs(self, output_mosaics):
        diffs = {}
        for i in output_mosaics:
            diffs[i] = self.groundtruth[i] + (output_mosaics[i] * self.groundtruth_class_count)

        return diffs

    def generate_diff_histograms(self, diff_rasters):
        diff_hists = {}
        for i in diff_rasters:
            diff_hists[i] = np.histogram(diff_rasters[i], bins=list(range((self.groundtruth_class_count * 2) + 1)))[0]
        return diff_hists

    def generate_shapes_from_diff(self, diff):
        with rasterio.Env():
            image = diff.astype('int16')
            tn = []
            fn = []
            fp = []
            tp = []
            for geometry, raster_value in rasterio.features.shapes(image):
                shape = {'properties': {'raster_value': raster_value}, 'geometry': geometry}
                if raster_value == 0:
                    tn.append(shape)
                if raster_value == 1:
                    fn.append(shape)
                if raster_value == 2:
                    fp.append(shape)
                if raster_value == 3:
                    tp.append(shape)

        result = {}
        result['true_negatives'] = gpd.GeoDataFrame.from_features(tn)
        result['false_negatives'] = gpd.GeoDataFrame.from_features(fn)
        result['false_positives'] = gpd.GeoDataFrame.from_features(fp)
        result['true_positives'] = gpd.GeoDataFrame.from_features(tp)
        return result

